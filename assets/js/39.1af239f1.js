(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{463:function(a,e,t){"use strict";t.r(e);var r=t(56),i=Object(r.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"webpack篇"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack篇"}},[a._v("#")]),a._v(" Webpack篇")]),a._v(" "),t("h3",{attrs:{id:"webapck简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webapck简介"}},[a._v("#")]),a._v(" Webapck简介")]),a._v(" "),t("p",[a._v("webpack 就像一条生产线，要经过一系列处理流程后才能将源文件转换成输出结果。 这条生产线上的每个处理流程的职责都是单一的，多个流程之间有存在依赖关系，只有完成当前处理后才能交给下一个流程去处理。 插件就像是一个插入到生产线中的一个功能，在特定的时机对生产线上的资源做处理。\nwebpack 通过 Tapable 来组织这条复杂的生产线。 webpack 在运行过程中会广播事件，插件只需要监听它所关心的事件，就能加入到这条生产线中，去改变生产线的运作。 webpack 的事件流机制保证了插件的有序性，使得整个系统扩展性很好。")]),a._v(" "),t("h3",{attrs:{id:"webpack常用配置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack常用配置"}},[a._v("#")]),a._v(" Webpack常用配置")]),a._v(" "),t("ul",[t("li",[a._v("Entry：入口，webpack构建的起始")]),a._v(" "),t("li",[a._v("Output: 出口，webpack生成文件的一些配置")]),a._v(" "),t("li",[a._v("Module：模块，webpack里面一切皆模块，也是代表着文件，从Entry配置的入口文件开始，递归找出依赖的模块")]),a._v(" "),t("li",[a._v("Chunk：代码块，找出递归依赖模块经转换后组合成代码块")]),a._v(" "),t("li",[a._v("Loader：模块转换器，也就是将模块的内容按照需求装换成新内容")]),a._v(" "),t("li",[a._v("Plugin：扩展插件，webpack构建过程中，会在特定的时机广播对应的事件，而插件可以监听这些事件的发生")]),a._v(" "),t("li",[a._v("devServer: 本地服务配置")])]),a._v(" "),t("h3",{attrs:{id:"webpack的生命流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack的生命流程"}},[a._v("#")]),a._v(" Webpack的生命流程")]),a._v(" "),t("p",[t("img",{attrs:{src:"/study/book/webpack_lifecycle.jpeg",alt:"完整流程"}}),t("br"),a._v("\nwebpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：")]),a._v(" "),t("ul",[t("li",[a._v("初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；")]),a._v(" "),t("li",[a._v("开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；")]),a._v(" "),t("li",[a._v("确定入口：根据配置中的 entry 找出所有的入口文件")]),a._v(" "),t("li",[a._v("编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；")]),a._v(" "),t("li",[a._v("完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；")]),a._v(" "),t("li",[a._v("输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；")]),a._v(" "),t("li",[a._v("输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。")])]),a._v(" "),t("p",[a._v("在以上过程中，webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 webpack 提供的 API 改变 webpack 的运行结果。")]),a._v(" "),t("h3",{attrs:{id:"webpack如何打包优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack如何打包优化"}},[a._v("#")]),a._v(" webpack如何打包优化")]),a._v(" "),t("h4",{attrs:{id:"打包资源优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#打包资源优化"}},[a._v("#")]),a._v(" 打包资源优化")]),a._v(" "),t("ul",[t("li",[a._v("公用包的抽离，webpack3的CommonsChunkPlugin到webpack4的optimization.splitChunks 和 optimization.runtimeChunk")]),a._v(" "),t("li",[a._v("资源压缩optimize.UglifyJsPlugin 废弃，由 optimization.minimize 替代")])]),a._v(" "),t("h4",{attrs:{id:"打包优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#打包优化"}},[a._v("#")]),a._v(" 打包优化")]),a._v(" "),t("ul",[t("li",[a._v("缩小编译范围，减少不必要的编译工作，即 modules、mainFields、noParse、includes、exclude、alias等")]),a._v(" "),t("li",[a._v("通过 externals 配置来提取常用库，引用cdn")]),a._v(" "),t("li",[a._v("dllPlugin，动态链接第三方库")]),a._v(" "),t("li",[a._v("使用Happypack，将loader由单进程转为多进程")]),a._v(" "),t("li",[a._v("可视化打包，webpack-bundle-analyzer，各个模块的大小和依赖关系呈现出来")])]),a._v(" "),t("h3",{attrs:{id:"loader和plugin的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#loader和plugin的区别"}},[a._v("#")]),a._v(" loader和plugin的区别")]),a._v(" "),t("ul",[t("li",[a._v("loader完成相应文件的转化处理（css-loader是否使用cssModule）")]),a._v(" "),t("li",[a._v("plugin通过注入的compiler监听整个构建过程中的事件，修改生成文件")]),a._v(" "),t("li")]),a._v(" "),t("h3",{attrs:{id:"webpack原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack原理"}},[a._v("#")]),a._v(" webpack原理")]),a._v(" "),t("p",[t("a",{attrs:{href:"https://segmentfault.com/a/1190000018385415?utm_source=sf-related",target:"_blank",rel:"noopener noreferrer"}},[a._v("手动实现webpack"),t("OutboundLink")],1)]),a._v(" "),t("h3",{attrs:{id:"runtime和manifest的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#runtime和manifest的区别"}},[a._v("#")]),a._v(" runtime和manifest的区别")]),a._v(" "),t("ul",[t("li",[a._v("runtime就是调度更新，删除或修改文件的变化")]),a._v(" "),t("li",[a._v("manifest把打包后的文件和源文件做个映射")])])])}),[],!1,null,null,null);e.default=i.exports}}]);